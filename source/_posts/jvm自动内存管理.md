---
title: jvm自动内存管理
date: 2019-03-07 22:12:47
tags: jvm
---

## 1. 运行时数据区
* 包括：方法区、虚拟机栈、本地方法栈、堆、程序计数器
* ![avatar](/uploads/image/jvm运行时数据区.jpg)


### 1.1 程序计数器
* 当前线程所执行的字节码的行号指示器，每个线程拥有一个独立的程序计数器

### 1.2 java虚拟机栈
* java虚拟机栈是线程私有的，生命周期与线程相同
* 虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息

### 1.3 本地方法栈
* 与虚拟机栈发挥的作用非常相似，它们之前的区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的native方法服务

### 1.4 java堆
* 是虚拟机所管理的内存中最大的一块
* java堆是垃圾收集器管理的主要区域
* 分配区缓冲的目的：由于堆是所有线程共享的，为了减少个线程在堆上创建对象失败次数，所以预先分配以供线程使用

### 1.5 方法区
* 用于存储虚拟机加载的类信息、常亮、静态变量、及时编译后的代码等数据
* 别名：Non-Heap（非堆） 

### 1.6 运行时常量池
* 运行时常量池时方法区的一部分，

### 1.7 直接内存
* 直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域
* NIO类中，引入了一种基于通道与缓冲区（buffer）的I/O方式，它可以使用native函数直接分配堆外内存，然后通过一个存储在java堆中的DirectoryByteBuffer对象作为这块内存的引用进行操作


## 2. 对象

### 2.1 对象的创建
* 对象的创建方式有两种：指针碰撞、空闲列表
* 本地线程分配缓冲（Thread Local Allocation Buffer， TLAB），虚拟机是否需要使用TLAB，可以通过-XX:+/-UseTLAB参数设定

### 2.2 对象的内存布局
* 对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充
* 对象头的一部分存储：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，另一部分是类型指正，即对象指向它的类元数据的指针
* 对齐填充作用：保证对象的起始地址是8字节的整数倍

### 2.3 对象的访问定位
* 访问方式：句柄、直接指针

## 3. OutOfMemoryError异常

### 3.1 堆内存溢出
* -XX:HeapDumpOnOutOfMemoryErro 可以让虚拟机在出现内存溢出是dump出当前的内存堆转储快照
* 分析工具 eclipse memory analyzer

### 3.2 虚拟机栈和本地方法栈溢出
* 线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常
* 虚拟机在扩张栈时，无法申请到足够的内存空间，则抛出OutOfMemoryErro异常
* -Xss128k 参数可以减少栈的内存容量

### 3.3 方法区和运行时常量池溢出
* 在JDK1.6及以前的版本中，常量池分配在永久代内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小
* CGLib、jsp或动态产生jsp文件的应用、基于OSGi的应用很可能会导致方法区溢出

### 3.4 本机内存溢出
* DirectMemory容量可以通过 -XX:MaxDirectMemorySize指定，如果不指定，默认与java堆最大值（-Xmx指定）一样

## 3. 垃圾收集器











